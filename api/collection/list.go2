package collection

import (
	"fmt"
	"reflect"
)

// List is a immutable interface of List collection.
type List[T any] interface {
	head() T
	tail() List[T]
	IsEmpty() bool
	Append(value T) List[T]
	AppendAll(values []T) List[T]
	Length() int
	Filter(func(T) bool) List[T]
	Remove(value T) List[T]
	RemovePredicate(func(T) bool) List[T]
	Insert(int, T) (List[T], error)
}

func MapList[T any, U any](list List[T], mapper func(T) U) List[U] {
	result := Empty[U]()
	if list.IsEmpty() {
		return result
	}
	return newCons[U](mapper(list.head()), MapList(list.tail(), mapper))
}

func Empty[T any]() List[T] {
	return empty[T]{}
}

func Of[T any](value T) List[T] {
	return newCons[T](value, Empty[T]())
}

func OfSlice[T any](elements []T) List[T] {
	result := Empty[T]()
	return result.AppendAll(elements)
}

type cons[T any] struct {
	consHead T
	consTail List[T]
	length   int
}

func newCons[T any](value T, tail List[T]) List[T] {
	return cons[T]{
		consHead: value,
		consTail: tail,
		length:   1 + tail.Length(),
	}
}

func (c cons[T]) head() T {
	return c.consHead
}

func (c cons[T]) tail() List[T] {
	return c.consTail
}

func (c cons[T]) IsEmpty() bool {
	return false
}

func (c cons[T]) Append(value T) List[T] {
	return newCons(c.consHead, c.consTail.Append(value))
}

func (c cons[T]) AppendAll(values []T) List[T] {
	result := newCons[T](c.consHead, c.consTail)
	for _, value := range values {
		result = result.Append(value)
	}
	return result
}

func (c cons[T]) Length() int {
	return c.length
}

func (c cons[T]) Filter(predicate func(T) bool) List[T] {
	if predicate(c.consHead) {
		return newCons[T](c.consHead, c.consTail.Filter(predicate))
	}
	if c.tail().IsEmpty() {
		return c.consTail
	}
	return newCons(c.consTail.head(), c.consTail.tail()).Filter(predicate)
}

func (c cons[T]) Remove(value T) List[T] {
	if !reflect.DeepEqual(c.consHead, value) {
		return newCons(c.consHead, c.consTail.Remove(value))
	}
	if c.consTail.IsEmpty() {
		return c.consTail
	}
	return newCons(c.consTail.head(), c.consTail.tail()).Remove(value)
}

func (c cons[T]) RemovePredicate(predicate func(T) bool) List[T] {
	if !predicate(c.consHead) {
		return newCons(c.consHead, c.consTail.RemovePredicate(predicate))
	}
	if c.consTail.IsEmpty() {
		return c.consTail
	}
	return newCons(c.consTail.head(), c.consTail.tail()).RemovePredicate(predicate)
}

func (c cons[T]) Insert(index int, value T) (List[T], error) {
	if index < 0 {
		return Empty[T](), fmt.Errorf("index out of range %d on List", index)
	}
	if index == 0 {
		return newCons[T](value, c), nil
	}
	if c.IsEmpty() {
		return Empty[T](), fmt.Errorf("index out of range %d on List", index)
	}
	tail, err := c.consTail.Insert(index-1, value)
	if err != nil {
		return Empty[T](), err
	}
	return newCons[T](c.consHead, tail), nil

}

type empty[T any] struct{}

func (n empty[T]) head() T {
	return *new(T)
}

func (n empty[T]) tail() List[T] {
	return Empty[T]()
}

func (n empty[T]) IsEmpty() bool {
	return true
}

func (n empty[T]) Length() int {
	return 0
}

func (n empty[T]) Append(value T) List[T] {
	return newCons[T](value, Empty[T]())
}

func (n empty[T]) AppendAll(elements []T) List[T] {
	result := Empty[T]()
	for _, element := range elements {
		result = result.Append(element)
	}
	return result
}

func (n empty[T]) Filter(predicate func(T) bool) List[T] {
	return n
}

func (n empty[T]) Remove(value T) List[T] {
	return n
}

func (n empty[T]) RemovePredicate(predicate func(T) bool) List[T] {
	return n
}

func (n empty[T]) Insert(index int, value T) (List[T], error) {
	if index != 0 {
		return n, fmt.Errorf("index out of range %d on empty List", index)
	}
	return newCons[T](value, n), nil
}
